## 1. Maven 基础

### 1.1 概念与作用

- Maven：Apache 旗下的开源项目管理与构建工具
- 核心：用 `pom.xml`（POM：Project Object Model）描述项目，通过“描述信息”驱动依赖管理与构建流程
- 主要作用
  - 依赖管理
    - 以前：手动下载 jar → 放进项目 lib → 自己处理版本冲突
    - 现在：在 `pom.xml` 声明依赖坐标 → Maven 自动下载/引入 → 统一管理版本与依赖关系
  - 项目构建（跨平台、标准化）
    - 常见过程：编译、测试、打包、发布
    - Maven 用统一命令完成（Windows / Linux / Mac 一致）
  - 统一项目结构
    - 普通 Java 工程目录在不同 IDE 里可能不一致
    - Maven 工程遵循固定结构，便于迁移与协作
- 核心模型（合并理解）
  - POM 模型：用 `pom.xml` 把项目“抽象成对象”（坐标、依赖、构建配置等）
  - 依赖管理模型：用“坐标”描述依赖资源
  - 构建生命周期：把构建过程抽象成阶段（phase），由插件完成实际工作

### 1.2 仓库与安装配置

- 仓库类型
  - 本地仓库：自己电脑上的目录（依赖/插件最终存放位置）
  - 中央仓库：公共仓库
  - 远程仓库（私服）：公司内部私有仓库
- 依赖查找/下载顺序
  - 默认：本地仓库 → 中央仓库（本地没有才下载到本地）
  - 配置私服后：本地仓库 → 远程仓库（私服）→ 中央仓库
- Maven 安装目录（解压即用，路径避免中文/特殊字符）
  - `bin/`：命令（重点：`mvn`）
  - `conf/`：配置（重点：`settings.xml`）
  - `lib/`：Maven 自身依赖
- `settings.xml` 常用配置
  - 本地仓库位置：`<localRepository>...</localRepository>`
```xml
<localRepository>E:\develop\mvn_repo</localRepository>
```
  - 镜像（加速下载，示例：阿里云镜像）
```xml
<mirror>
  <id>alimaven</id>
  <name>aliyun maven</name>
  <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
  <mirrorOf>central</mirrorOf>
</mirror>
```
  - 默认 JDK（可选，示例：17）
```xml
<profile>
  <id>jdk-17</id>
  <activation>
    <activeByDefault>true</activeByDefault>
    <jdk>17</jdk>
  </activation>
  <properties>
    <maven.compiler.source>17</maven.compiler.source>
    <maven.compiler.target>17</maven.compiler.target>
    <maven.compiler.compilerVersion>17</maven.compiler.compilerVersion>
  </properties>
</profile>
```
- 环境变量与验证
  - `MAVEN_HOME = Maven 解压目录`
  - `Path` 添加：`%MAVEN_HOME%\bin`
  - 验证：
```bash
mvn -v
```

### 1.3 IDEA 集成与 Maven 项目基础

- IDEA 全局配置 Maven（建议先配好再建/导入项目）
  - Settings：`Build, Execution, Deployment -> Build Tools -> Maven`
  - 指定 Maven Home、`settings.xml`、Local repository
  - 同时配置工程编译版本（如 17）：`Java Compiler` 设置 `Project bytecode version`
- Maven 标准目录结构
  - `src/main/java`：主程序 Java 源码
  - `src/main/resources`：主程序配置文件
  - `src/test/java`：测试代码
  - `src/test/resources`：测试配置
  - `target/`：编译/打包产物
- `pom.xml` 基础结构与关键标签
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             http://maven.apache.org/xsd/maven-4.0.0.xsd">

  <modelVersion>4.0.0</modelVersion>

  <!-- 当前项目坐标 -->
  <groupId>com.itheima</groupId>
  <artifactId>maven-project01</artifactId>
  <version>1.0-SNAPSHOT</version>

  <!-- 项目的JDK版本及编码 -->
  <properties>
    <maven.compiler.source>17</maven.compiler.source>
    <maven.compiler.target>17</maven.compiler.target>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
  </properties>

</project>
```
  - 标签含义
    - `<modelVersion>`：POM 模型版本（常见 4.0.0）
    - 坐标：`groupId + artifactId + version`
    - `<properties>`：编译版本、编码等全局属性
- Maven 坐标（资源唯一标识）
  - `groupId`：组织名（常用域名反写）
  - `artifactId`：模块/项目名
  - `version`：版本号
    - `SNAPSHOT`：快照版本（开发中）
    - `RELEASE`：发行版本（相对稳定）
- Maven 项目导入（IDEA 常见方式）
  - 方式一：导入模块时选择 `pom.xml`
  - 方式二：Maven 面板 `Add Maven Projects (+)` 选择 `pom.xml`
  
  

### 1.4 依赖管理

#### 1.4.1 依赖配置
- 依赖统一写在 `pom.xml` 的 `<dependencies>` 中，每个依赖用一个 `<dependency>` 表示
- 坐标三要素：`groupId + artifactId + version`
- 常见可选项：`scope`（依赖范围）

```xml
<dependencies>
    <!-- 依赖：spring-context -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>6.1.4</version>
    </dependency>
</dependencies>
```

#### 1.4.2 依赖查找与导入
- 通过中央仓库网站查找：搜索依赖名称 → 选版本 → 复制 Maven 依赖片段到 `pom.xml`
- 在 IDEA 中导入/刷新：添加依赖后等待自动导入；必要时手动触发 Maven 重新导入

#### 1.4.3 依赖传递
- 传递依赖：A 依赖 B，B 依赖 C，则 A 会间接获得 C
- 风险：可能引入不需要的依赖，或出现版本/包冲突

#### 1.4.4 排除依赖
- 用于解决“传递依赖不需要/冲突”等问题
- 写法：在目标依赖中添加 `<exclusions>`，每个 `<exclusion>` 指定要排除的 `groupId + artifactId`

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>6.1.4</version>

    <exclusions>
        <exclusion>
            <groupId>io.micrometer</groupId>
            <artifactId>micrometer-observation</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

### 1.5 生命周期

#### 1.5.1 生命周期与阶段
- 生命周期：把构建过程抽象为一系列阶段（phase），真正执行工作的是插件（plugin）
- 三套生命周期（相互独立）
  - `clean`：清理
  - `default`：核心（编译、测试、打包、安装、部署等）
  - `site`：站点/报告
- 常用阶段
  - `clean`：清理上次构建产物
  - `compile`：编译源代码
  - `test`：运行单元测试
  - `package`：打包
  - `install`：安装到本地仓库

#### 1.5.2 阶段执行规则
- 同一生命周期中：执行“后面的阶段”会自动把“前面的阶段”一起执行
- 关键结论：执行 `package` 时
  - `compile` 会执行（同属 default）
  - `clean` 不会执行（属于 clean 生命周期）

#### 1.5.3 执行方式
- IDEA：Maven 面板 → `Lifecycle` → 双击阶段执行
- 命令行：进入 `pom.xml` 同级目录执行

```bash
mvn clean
mvn compile
mvn test
mvn package
mvn install
```

​	

## 2. 单元测试（JUnit）

### 2.1 测试基础

#### 2.1.1 测试阶段
- 单元测试、集成测试、系统测试、验收测试

#### 2.1.2 测试方法
- 白盒测试：了解代码结构与逻辑
- 黑盒测试：只关注功能输入输出
- 灰盒测试：结合两者

  

### 2.2 JUnit 基本使用

#### 2.2.1 为什么不建议用 main 方法测试
- 测试与业务代码混在一起，不规范、不易维护
- 失败可能影响后续测试执行
- 不利于自动化与结果统计

#### 2.2.2 引入依赖（示例）
```xml
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter</artifactId>
    <version>5.9.1</version>
    <scope>test</scope>
</dependency>
```

#### 2.2.3 编写与运行测试（示例）
- 测试类放在 `src/test/java`
- 测试方法用 `@Test` 标记

```java
@Test
public void testGetAge() {
    Integer age = new UserService().getAge("110002200505091218");
    System.out.println(age);
}
```

- 运行结果：通过（绿色）/ 失败（红色）

#### 2.2.4 命名规范
- 测试类：`XxxTest`
- 测试方法：`public void xxx(){...}`

  

### 2.3 断言（Assertions）

#### 2.3.1 断言作用
- 判断实际结果是否符合预期，不符合则报错，帮助定位问题

#### 2.3.2 常用断言
- `assertEquals(exp, act, msg)`、`assertNotEquals(unexp, act, msg)`
- `assertNull(act, msg)`、`assertNotNull(act, msg)`
- `assertTrue(condition, msg)`、`assertFalse(condition, msg)`
- `assertSame(exp, act, msg)`

#### 2.3.3 断言示例
```java
@Test
public void testGetAge2() {
    Integer age = new UserService().getAge("110002200505091218");
    Assertions.assertNotEquals(18, age, "两个值相等");
}

@Test
public void testGetGender2() {
    String gender = new UserService().getGender("612429198904201611");
    Assertions.assertEquals("男", gender);
}
```

​	

### 2.4 常用注解

#### 2.4.1 注解速记
- `@Test`：测试方法
- `@BeforeEach` / `@AfterEach`：每个测试方法前/后执行一次
- `@BeforeAll` / `@AfterAll`：所有测试方法前/后只执行一次（必须 `static`）
- `@ParameterizedTest`：参数化测试
- `@ValueSource`：参数来源
- `@DisplayName`：显示名称

#### 2.4.2 Before/After 示例
```java
public class UserServiceTest {

    @BeforeEach
    public void testBefore() {
        System.out.println("before...");
    }

    @AfterEach
    public void testAfter() {
        System.out.println("after...");
    }

    @BeforeAll
    public static void testBeforeAll() {
        System.out.println("before all ...");
    }

    @AfterAll
    public static void testAfterAll() {
        System.out.println("after all...");
    }
}
```

#### 2.4.3 DisplayName + 参数化测试示例
```java
@DisplayName("测试-学生业务操作")
public class UserServiceTest {

    @DisplayName("测试-获取年龄")
    @Test
    public void testGetAge() {
        Integer age = new UserService().getAge("110002200505091218");
        System.out.println(age);
    }

    @DisplayName("测试-获取性别3")
    @ParameterizedTest
    @ValueSource(strings = {"612429198904201611","612429198904201631","612429198904201626"})
    public void testGetGender3(String idcard) {
        String gender = new UserService().getGender(idcard);
        System.out.println(gender);
    }
}
```

### 2.5 依赖范围（scope）

#### 2.5.1 scope 的意义
- 用于限制依赖在不同场景的可见性：主程序、测试程序、打包/运行

#### 2.5.2 scope 示例：test
- 只在测试代码可用，主程序不可用，且不参与打包运行

```xml
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter</artifactId>
    <version>5.9.3</version>
    <scope>test</scope>
</dependency>
```

#### 2.5.3 常见 scope 记忆
- `compile（默认）`：主程序 Y / 测试程序 Y / 打包(运行) Y
- `test`：主程序 - / 测试程序 Y / 打包(运行) -
- `provided`：主程序 Y / 测试程序 Y / 打包(运行) -
- `runtime`：主程序 - / 测试程序 Y / 打包(运行) Y